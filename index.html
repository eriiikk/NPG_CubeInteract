<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Three.js Cube with Clickable Plane</title>
    <meta name="description" content="3D Space Cube with Clickable Plane">

    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
      }
    }
  </script>

    <style>
        body, html {
            margin: 0;
            overflow: hidden;
        }
        #render-canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #popup {
            position: absolute;
            top: 0;
            right: -40%; /* Start off-screen */
            width: 40%;
            height: 100%;
            background: linear-gradient(145deg, rgba(240, 248, 255, 0.92), rgba(230, 240, 255, 0.82));
            backdrop-filter: blur(15px) contrast(50%);
            opacity: 0; /* Hidden by default */
            transition: opacity 0.5s ease, right 0.5s ease; /* Animate opacity and right property */
            pointer-events: none; /* Prevent interaction when hidden */
			border: 1px dashed #000000;
			padding-left: 1vw;
            overflow: auto;
        }
        #popup.show {
            margin: auto;
            right: 0; /* Bring into view */
            opacity: 1; /* Make visible */
            pointer-events: auto; /* Enable interaction when visible */
        }
    </style>
</head>

<body>
    <div id="render-canvas"></div>
	<div id="popup">Loading content...</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        //Setup canvas and raycast to track screen clicks to 3D space
        var renderCanvas = document.getElementById('render-canvas');
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        // Set up scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, renderCanvas.offsetWidth/renderCanvas.offsetHeight, 0.1, 1000);
        camera.position.z = 2.5;
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(renderCanvas.offsetWidth, renderCanvas.offsetHeight);
        renderCanvas.appendChild(renderer.domElement);

        // Create a cube
        const cubeGeometry = new THREE.BoxGeometry();
        const cubeMaterial = new THREE.MeshStandardMaterial({ color: 0xfcfcfc,  metalness: 0.3, roughness: 0.7 });
        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.rotation.y = 0.3; // Rotate slightly on the y-axis
        scene.add(cube);

        // Add a plane on the right side of the cube (clickable button)
        const planeGeometry = new THREE.PlaneGeometry(0.25, 0.25); // Create a plane
        const planeTexture = new THREE.TextureLoader().load('infoGFX.png'); // Load image
        const planeMaterial = new THREE.MeshBasicMaterial({ map: planeTexture, side: THREE.DoubleSide, transparent: true });
        const planeHoverMaterial = new THREE.MeshBasicMaterial({ map: planeTexture, color: 0x474a61, side: THREE.DoubleSide, transparent: true }); // Yellow color for hover

        const plane = new THREE.Mesh(planeGeometry, planeMaterial);

        // Position the plane to be on the right side of the cube
        plane.position.set(0.51, 0, 0); // Position the plane on the right side
        plane.rotation.y = Math.PI / 2; // Rotate the plane to face outward
        cube.add(plane); // Add the plane to the scene

        // Add ambient light (soft overall lighting)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // color, intensity
        scene.add(ambientLight);

        // Add directional light (simulates sunlight)
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1); // color, intensity
        directionalLight.position.set(5, 5, 5); // position the light source
        scene.add(directionalLight);

        // Add OrbitControls to allow zooming and rotation
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Smooth controls
        controls.dampingFactor = 0.05; // Damping factor for smooth motion
        controls.screenSpacePanning = false; // Prevent panning up/down when dragging with left mouse

        // Handle window resizing
        window.addEventListener('resize', () => {
           // Ensure the renderer size matches the window's size
           camera.aspect = renderCanvas.offsetWidth / renderCanvas.offsetHeight;
           camera.updateProjectionMatrix();
           renderer.setSize(renderCanvas.offsetWidth, renderCanvas.offsetHeight);
        });

        // Add both mouse click and touchstart event listeners
        window.addEventListener('click', onMouseClick, false);
        window.addEventListener('touchstart', onTouchStart, false);
        window.addEventListener('mousemove', onMouseMove, false);

        function onTouchStart(event) {
            event.preventDefault(); // Prevent default scrolling behavior

            // Only handle the first touch point
            if (event.touches.length === 1) {
                const touch = event.touches[0];

                // Calculate touch position in normalized device coordinates (-1 to +1) relative to the canvas
                pointer.x = (touch.clientX / renderer.domElement.clientWidth) * 2 - 1;
                pointer.y = -(touch.clientY / renderer.domElement.clientHeight) * 2 + 1;

                checkIntersects();
            }
        }

        function onMouseClick(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

            checkIntersects();
        }

        function onMouseMove(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

            checkIntersectsHover();
        }

        function checkIntersects() {
            // Update the raycaster with the camera and pointer position
            raycaster.setFromCamera(pointer, camera);

            // Calculate objects intersecting with the ray
            const intersects = raycaster.intersectObjects([plane]);

            // Check if the popup is visible
            const isPopupVisible = popup.classList.contains('show');

            // Get the bounding rectangle of the popup
            const popupRect = popup.getBoundingClientRect();

            // Check if the click/tap is within the popup
            const isInsidePopup = (
                pointer.x >= (popupRect.left / window.innerWidth) * 2 - 1 &&
                pointer.x <= (popupRect.right / window.innerWidth) * 2 - 1 &&
                pointer.y >= -(popupRect.bottom / window.innerHeight) * 2 + 1 && // Inverted Y coordinate
                pointer.y <= -(popupRect.top / window.innerHeight) * 2 + 1 // Inverted Y coordinate
            );

            if (intersects.length > 0) {
                // Plane is clicked or tapped
                onPlaneClick();
            } else if (isPopupVisible && !isInsidePopup) {
                // If the popup is visible and the click/tap was outside, close it
                popup.classList.remove('show'); // Remove class to trigger closing animation
            }
        }

        let previousIntersected = null; // Store previously intersected object
        function checkIntersectsHover() {
            // Update the raycaster with the camera and pointer position
            raycaster.setFromCamera(pointer, camera);

            // Calculate objects intersecting with the ray
            const intersects = raycaster.intersectObjects([plane]);

            // Check hover effect
            if (intersects.length > 0) {
                if (previousIntersected !== plane) {
                    // Change the material to hover material
                    plane.material = planeHoverMaterial;
                    previousIntersected = plane; // Update previously intersected
                }
            } else {
                // Reset to original material if not hovering
                if (previousIntersected !== null) {
                    plane.material = planeMaterial;
                    previousIntersected = null; // Reset previous intersected
                }
            }
        }

        // Custom function called when the plane is clicked
        function onPlaneClick() {
			popup.innerHTML = "Loading...";
			popup.classList.add('show'); // Add the class to trigger the animation
			loadPopupContent('popup.html');

            //Code to handle Scorm wrapper for Cornerstone systems goes here
            ///...
        }

		async function loadPopupContent(url) {
			try {
                const response = await fetch(url); // Load your desired URL here
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                const content = await response.text(); // Get the response text
                popup.innerHTML = content; // Display the content inside the popup
                popup.classList.add('show'); // Add the class to trigger the animation
            } catch (error) {
                console.error('Error fetching content:', error);
                popup.innerHTML = 'Failed to load content. Please try again later.';
            }
		}

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Orbit controls
            renderer.render(scene, camera);
        }

        animate(); //Start animation loop
    </script>
</body>
</html>
