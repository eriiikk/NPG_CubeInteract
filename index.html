<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Three.js Cube with Clickable Plane</title>
    <meta name="description" content="3D Space Cube with Clickable Plane">

    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
      }
    }
  </script>

    <style>
        body, html {
            margin: 0;
            height: 100%; 
        }
        #render-canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
        #popup {
            position: absolute;
            top: 0;
            right: -40%; /* Start off-screen */
            width: 40%;
            height: 100vh;
            background: linear-gradient(145deg, rgba(240, 248, 255, 0.92), rgba(230, 240, 255, 0.82));
            backdrop-filter: blur(15px) contrast(50%);
            opacity: 0; /* Hidden by default */
            transition: opacity 0.5s ease, right 0.5s ease; /* Animate opacity and right property */
            pointer-events: none; /* Prevent interaction when hidden */
			border-left: 1px solid #000000;
			padding-left: 1vw;
        }
        #popup.show {
            right: 0; /* Bring into view */
            opacity: 1; /* Make visible */
            pointer-events: auto; /* Enable interaction when visible */
        }
    </style>
</head>

<body>
    <canvas id="render-canvas"></canvas>
	<div id="popup">Loading content...</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const canvas = document.getElementById('render-canvas');
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        // Set up scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, canvas.clientWidth/canvas.clientHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true });
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);

        // Create a cube
        const cubeGeometry = new THREE.BoxGeometry();
        const cubeMaterial = new THREE.MeshStandardMaterial({ color: 0xfcfcfc,  metalness: 0.3, roughness: 0.7 });
        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);

        // Set the cube's initial rotation
        cube.rotation.y = 0.3; // Rotate slightly on the y-axis

        //Add cube to scene
        scene.add(cube);

        // Position the camera slightly away from the cube
        camera.position.z = 2.5;

        // Add a plane on the right side of the cube
        const planeGeometry = new THREE.PlaneGeometry(0.25, 0.25); // Create a plane
        const planeTexture = new THREE.TextureLoader().load('infoGFX.png'); // Load image
        const planeMaterial = new THREE.MeshBasicMaterial({ map: planeTexture, side: THREE.DoubleSide, transparent: true });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);

        // Position the plane to be on the right side of the cube
        plane.position.set(0.51, 0, 0); // Position the plane on the right side
        plane.rotation.y = Math.PI / 2; // Rotate the plane to face outward
        cube.add(plane); // Add the plane to the scene

        // Add ambient light (soft overall lighting)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // color, intensity
        scene.add(ambientLight);

        // Add directional light (simulates sunlight)
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1); // color, intensity
        directionalLight.position.set(5, 5, 5); // position the light source
        scene.add(directionalLight);


        // Add OrbitControls to allow zooming and rotation
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Smooth controls
        controls.dampingFactor = 0.05; // Damping factor for smooth motion
        controls.screenSpacePanning = false; // Prevent panning up/down when dragging with left mouse

        // Handle window resizing
        window.addEventListener('resize', () => {
           // Ensure the renderer size matches the window's size
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Adjust the camera aspect ratio to the new size
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });


        // Add both mouse click and touchstart event listeners
        window.addEventListener('click', onMouseClick, false);
        window.addEventListener('touchstart', onTouchStart, false);

        function onTouchStart(event) {
            event.preventDefault(); // Prevent default scrolling behavior

            // Only handle the first touch point
            if (event.touches.length === 1) {
                const touch = event.touches[0];

                // Calculate touch position in normalized device coordinates (-1 to +1) relative to the canvas
                pointer.x = (touch.clientX / renderer.domElement.clientWidth) * 2 - 1;
                pointer.y = -(touch.clientY / renderer.domElement.clientHeight) * 2 + 1;

                checkIntersects();
            }
        }

        function onMouseClick(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

            checkIntersects();
        }

        function onTouchEnd(event) {
        // Prevent default touch behavior to avoid mobile scrolling when interacting
        event.preventDefault();

        // Only handle the first touch point
        if (event.touches.length === 1) {
            const touch = event.touches[0];

            // Calculate touch position in normalized device coordinates (-1 to +1)
            pointer.x = (touch.pageX / window.innerWidth) * 2 - 1;
            pointer.y = -(touch.pageY / window.innerHeight) * 2 + 1;

            checkIntersects();
        }
    }


        function checkIntersects() {
            // Update the raycaster with the camera and pointer position
            raycaster.setFromCamera(pointer, camera);

            // Calculate objects intersecting with the ray
            const intersects = raycaster.intersectObjects([plane]);

            // Check if the popup is visible
            const isPopupVisible = popup.classList.contains('show');

            // Get the bounding rectangle of the popup
            const popupRect = popup.getBoundingClientRect();

            // Check if the click/tap is within the popup
            const isInsidePopup = (
                pointer.x >= popupRect.left &&
                pointer.x <= popupRect.right &&
                pointer.y >= popupRect.top &&
                pointer.y <= popupRect.bottom
            );

            if (intersects.length > 0) {
                // Plane is clicked or tapped
                onPlaneClick();
            } else if (isPopupVisible && !isInsidePopup) {
                // If the popup is visible and the click/tap was outside, close it
                popup.classList.remove('show'); // Remove class to trigger closing animation
            }
        }


        // Custom function called when the plane is clicked
        function onPlaneClick() {
			popup.innerHTML = "Loading...";
			popup.classList.add('show'); // Add the class to trigger the animation
			loadPopupContent('popup.html');

            //Code to handle Scorm wrapper for Cornerstone systems goes here
            ///...
        }

		async function loadPopupContent(url) {
			try {
                const response = await fetch(url); // Load your desired URL here
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                const content = await response.text(); // Get the response text
                popup.innerHTML = content; // Display the content inside the popup
                popup.classList.add('show'); // Add the class to trigger the animation
            } catch (error) {
                console.error('Error fetching content:', error);
                popup.innerHTML = 'Failed to load content. Please try again later.';
            }
		}

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Update controls (for damping to work)
            renderer.render(scene, camera); // Render the scene
        }

        animate();
    </script>
</body>
</html>
