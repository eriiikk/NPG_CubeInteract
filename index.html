<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>NPG Test - Kube</title>
    <meta name="description" content="Interaktiv 3D kube">

    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
      }
    }
    </script>

    <style>
        body, html {
            margin: 0;
            overflow: hidden;
        }
        #render-canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #popup {
            position: absolute;
            top: 10%;
            right: -40%; /* Start off-screen */
            opacity: 0; /* Hidden by default */
            transition: opacity 0.5s ease, right 0.5s ease;
            width: 40%;
            height: 80%;
            background: linear-gradient(145deg, rgba(42, 100, 246, 0.75), rgba(42, 100, 246, 0.25)); /* Dark blue */
            backdrop-filter: blur(15px) contrast(25%);
            pointer-events: none;
            border: 5px solid #2A64F6;
            border-right: 0;
            padding: 1.25vw;
            padding-left: 2.5vw;
            overflow: auto;
            border-top-left-radius: 3px; 
            border-bottom-left-radius: 3px; 
        }
        #popup.show {
            margin: auto;
            right: 0; /* Bring into view */
            opacity: 1; /* Make visible */
            pointer-events: auto;
        }
    </style>
</head>

<body>
    <div id="render-canvas"></div>
	<div id="popup">Loading content...</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        //Setup canvas and raycast to track screen clicks to 3D space
        var renderCanvas = document.getElementById('render-canvas');
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        // Set up scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, renderCanvas.offsetWidth/renderCanvas.offsetHeight, 0.1, 1000);
        camera.position.z = 2.0;
        camera.position.y = 1.25;
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(renderCanvas.offsetWidth, renderCanvas.offsetHeight);
        renderCanvas.appendChild(renderer.domElement);

        // Create a cube
        /*
        const cubeGeometry = new THREE.BoxGeometry();
        const cubeMaterial = new THREE.MeshStandardMaterial({ color: 0xfcfcfc,  metalness: 0.3, roughness: 0.7 });
        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.rotation.y = 0.3; // Rotate slightly for more interesting starting angle
        scene.add(cube);
        */

        //Load model instead of cube
        //Cardbox model CC0 from https://www.cgtrader.com/free-3d-models/household/other/cc0-cardboard-box-closed
        const gltfLoader = new GLTFLoader();
        const textureLoader = new THREE.TextureLoader();

        // Load the textures
        const albedoTexture = textureLoader.load('models/CardboardBoxClosedAlbedo1024.png');
        const normalTexture = textureLoader.load('models/CardboardBoxClosedNormal1024.png');
        const metallicRoughnessTexture = textureLoader.load('models/CardboardBoxClosedRough1024.png');

        // Load the GLTF model
        let model;
        gltfLoader.load('models/cc0_-_cardboard_box_closed_1K.glb', (gltf) => {
            model = gltf.scene;
            // Create a new MeshStandardMaterial with textures
            const cardboxMaterial = new THREE.MeshStandardMaterial({
                map: albedoTexture,
                normalMap: normalTexture,
                metalnessMap: metallicRoughnessTexture,
                roughnessMap: metallicRoughnessTexture,
                metalness: 0.4,
                roughness: 0.8,
            });

            // Apply albedo and normal maps to all materials of the model
            model.traverse((child) => {
                if (child.isMesh) {
                    child.material = cardboxMaterial;
                }
            });

            // Rotate the model slightly for a better starting angle
            scene.rotation.y = 0.35; //Rotate scene instead of object to keep the box and plane aligned
            model.scale.set(2.5,2.5,2.5);

            // Add the model to the scene
            scene.add(model);
        }, undefined, (error) => {
            console.error('Error loading the model:', error);
        });

        // Add a plane on the right side of the cube (clickable button)
        const planeGeometry = new THREE.PlaneGeometry(0.25, 0.25); // Create a plane
        const planeTexture = new THREE.TextureLoader().load('infoGFX.png'); // Load image
        const planeMaterial = new THREE.MeshBasicMaterial({ map: planeTexture, color: 0xB0C4DE, side: THREE.DoubleSide, transparent: true });
        const planeHoverMaterial = new THREE.MeshBasicMaterial({ map: planeTexture, color: 0x1F5BB8, side: THREE.DoubleSide, transparent: true }); // Material for hover FX

        const plane = new THREE.Mesh(planeGeometry, planeMaterial);

        // Position the plane to be on the right side of the cube
        plane.position.set(0.4524, 0, 0); // Position the plane on the right side
        plane.rotation.y = Math.PI / 2; // Rotate the plane to face outward
        scene.add(plane); // Add the plane

        // Ambient light
        const ambientLight = new THREE.AmbientLight(0xf8f1ea, 0.5);
        scene.add(ambientLight);

        // Directional light
        const directionalLight = new THREE.DirectionalLight(0xf4f8ea, 1);
        directionalLight.position.set(5, 10, 5); // position the light source
        scene.add(directionalLight);

        // Rim light for highlighting
        const rimLight = new THREE.DirectionalLight(0xffffff, 0.8);
        rimLight.position.set(-5, 5, 10);
        rimLight.castShadow = true; // Enable shadows for depth
        scene.add(rimLight);

        // Add OrbitControls to allow zooming and rotation
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Smooth controls
        controls.dampingFactor = 0.05; // Damping factor for smooth motion
        controls.screenSpacePanning = false; // Prevent panning up/down when dragging with left mouse

        // Handle window resizing
        window.addEventListener('resize', onResize, false);

        // Add mouse click, mouse over and touchstart event listeners
        window.addEventListener('click', onMouseClick, false);
        window.addEventListener('touchstart', onTouchStart, false);
        window.addEventListener('mousemove', onMouseMove, false);

        function onResize(event) {
            camera.aspect = renderCanvas.offsetWidth / renderCanvas.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(renderCanvas.offsetWidth, renderCanvas.offsetHeight);
        }

        function onTouchStart(event) {
            event.preventDefault(); // Prevent default scrolling behavior

            if (event.touches.length === 1) {
                const touch = event.touches[0];

                // Calculate touch position in normalized device coordinates (-1 to +1) relative to the canvas
                pointer.x = (touch.clientX / renderer.domElement.clientWidth) * 2 - 1;
                pointer.y = -(touch.clientY / renderer.domElement.clientHeight) * 2 + 1;

                checkIntersects();
            }
        }

        function onMouseClick(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

            checkIntersects();
        }

        function onMouseMove(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

            checkIntersectsHover();
        }

        function checkIntersects() {
            // Update the raycaster with the camera and pointer position
            raycaster.setFromCamera(pointer, camera);

            // Calculate objects intersecting with the ray
            const intersects = raycaster.intersectObjects([plane]);

            // Check if the pop-up is visible
            const isPopupVisible = popup.classList.contains('show');

            // Get the bounding rectangle of the popup
            const popupRect = popup.getBoundingClientRect();

            // Check if the click/tap is within the popup
            const isInsidePopup = (
                pointer.x >= (popupRect.left / window.innerWidth) * 2 - 1 &&
                pointer.x <= (popupRect.right / window.innerWidth) * 2 - 1 &&
                pointer.y >= -(popupRect.bottom / window.innerHeight) * 2 + 1 && // Inverted Y coordinate
                pointer.y <= -(popupRect.top / window.innerHeight) * 2 + 1 // Inverted Y coordinate
            );

            if (intersects.length > 0) {
                // Plane is clicked or tapped
                onPlaneClick();
            } else if (isPopupVisible && !isInsidePopup) {
                // If the popup is visible and the click/tap was outside, close it
                popup.classList.remove('show'); // Remove class to trigger closing animation
            }
        }

        // Mouse over, for hover effect
        let previousIntersected = null; // Store previously intersected object
        function checkIntersectsHover() {
            // Update the raycaster with the camera and pointer position
            raycaster.setFromCamera(pointer, camera);

            // Calculate objects intersecting with the ray
            const intersects = raycaster.intersectObjects([plane]);

            if (intersects.length > 0) {
                if (previousIntersected !== plane) {
                    // Change the material to hover material
                    plane.material = planeHoverMaterial;
                    previousIntersected = plane; // Update previously intersected
                    renderCanvas.style.cursor = 'pointer';
                }
            } else {
                // Reset to original material if not hovering
                if (previousIntersected !== null) {
                    plane.material = planeMaterial;
                    previousIntersected = null; // Reset previous intersected
                    renderCanvas.style.cursor = 'auto';
                }
            }
        }

        // Custom function called when the plane is clicked
        function onPlaneClick() {
			popup.innerHTML = "Loading...";
			popup.classList.add('show'); // Add the class to trigger the animation
			loadPopupContent('popup.html');

            //Code to handle Scorm wrapper for Cornerstone systems goes here
            ///...
        }
        
        async function loadPopupContent(url) {
            try {
                const response = await fetch(url); // Load your desired URL here
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                const content = await response.text(); // Get the response text
                popup.innerHTML = content; // Display the content inside the popup
                popup.classList.add('show'); // Add the class to trigger the animation
            } catch (error) {
                console.error('Error fetching content:', error);
                popup.innerHTML = 'Failed to load content. Please try again later.';
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Orbit controls
            renderer.render(scene, camera);
        }

        animate(); //Start animation loop
    </script>
</body>
</html>